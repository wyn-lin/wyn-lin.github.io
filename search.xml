<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java（第零篇）对象与类]]></title>
    <url>%2F2017%2F12%2F31%2Fjava-object-and-class%2F</url>
    <content type="text"><![CDATA[前言：本文讲述java中对象与类的一些概念。包括对象与类的有关概念，类间五种关系，类的访问权限等。 概述在java中，一切都可以用对象来描述，操作对象的标识符只不过是对象的一个引用，一个对象可以有多个引用，就像人可以有多个外号一样，但是这个外号不一定是真实存在这个人，可能以虚假的外号欺骗世人，引用亦如此，引用不一定需要有对象与之关联，一个引用倘若没有引用对象，那么这个引用就是null。而对于一个真实存在的对象，如果没有一个引用引用它，那么很不幸的，它将在不久的将来被jvm的垃圾回收器发现并回收。 类是对象的一个模板和蓝图，通过类这个模板可以创建出多个相似的对象。 对象初始化的过程在Java中，对象的创建通过new 关键字动态分配内存创建一个对象，也可以通过反射在运行时创建一个对象。对象在创建时的初始化过程如下： 首先，是执行顶层父类的静态初始化块，然后自顶向下一次执行所有静态初始化块。然后回到顶层父类执行顶层父类的实例初始化块，然后执行顶层父类的构造方法，接着往下一层同样从实例初始化开始，依次类推，直到该类自身，先执行该类自身的实例初始化块，然后执行构造方法 类的静态变量赋值顺序：在静态变量声明的地方赋值-&gt;静态初始化块赋值-&gt;构造方法赋值 类的普通成员变量的赋值顺序：在成员变量声明的地方赋值-&gt;在实例初始化块赋值-&gt;在构造方法赋值 看代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test&#123; public static void main(String[] args)&#123; new Son(); &#125;&#125;class Base&#123; protected int a = 1; protected static int b = 1; &#123; a = 2; b = 2; System.out.println("Base类的实例初始化块执行：a为"+a); &#125; static&#123; b = 3; System.out.println("Base类的静态初始化化块执行：b为"+b); &#125; public Base()&#123; b = 4; a = 4; System.out.println("Base类的构造方法执行：a为"+a); System.out.println("Base类的构造方法执行：b为"+b); &#125;&#125;class Son extends Base&#123; &#123; a = 6; b = 6; System.out.println("Son类的实例初始化块执行：a为"+a); &#125; static&#123; b = 7; System.out.println("Son类的静态初始化化块执行：b为"+b); &#125; public Son()&#123; a = 8; b = 8; System.out.println("Son类的构造方法执行：a为"+a); System.out.println("Son类的构造方法执行：b为"+b); &#125;&#125; 运行结果：如果运行结果如你所料，那么你基本掌握了这个知识点了，如果不是，那你要好好补补功课了。 类的构成类有方法和属性构成。属性例如商品的价格数量、人的性别年龄等。方法例如价格的税率计算等 类的访问权限类的访问权限有以下几种： 权限 同一个类 同一个包 同一个包的子类 不同包的子类 不同包中的类 private (私有) √ × × × × default (默认) √ √ √ × × protected (保护) √ √ √ √ × public (公有) √ √ √ √ √ 类重用类重用的方式主要是通过类间的继承关系和聚合组合关系实现的。 关于类的两种重用方式的区别与特点将在下篇文章总结。 关于类之间的关系类之间的关系主要有五种： 依赖(use-a) 关联(association) 聚合(has-a) 组合(contain-a) 继承(is-a) 1. 依赖关系是一种use-a的关系。一般而言，一个类A如果操作另一个类B的对象来实现某些功能，我们就称为A依赖于B。 表现为：方法参数传入另一个类的实例对象，静态方法的调用，在代码块和方法中定义的另一个类类型的局部变量等。 这种依赖关系是弱依赖，具有偶然性，并不是长期依赖，是在局部作用域内使用了另一个类的实例或者使用了另一个类的静态方法时。当调用类的方法时，才出现依赖关系 代码实例：1234567891011121314151617181920public class A&#123; //1. 参数形式 public void useOne(B b)&#123; b.showB();//使用b做一些事情 &#125; public void useTwo()&#123; //2. 局部变量形式 new B().showB(); //3. 静态方法形式 B.bb(); &#125;&#125;public class B&#123; public void showB()&#123; System.out.println("b hello world!"); &#125; public static void bb()&#123; System.out.println("B static hello world!"); &#125;&#125; 2. 关联关系是指在一个类中与另一个类有联系。 表现为成员变量的使用 关联关系分两种：单向关联和双向关联。 顾名思义，单向关联是指仅有一方关联了另一方，而双向关联指的是双方互相存在关联。 代码示例： 单向关联 1234567891011public class A&#123; private B b = new B(); public void useB()&#123; //使用b做一些事情 &#125;&#125;public class B&#123; &#125; 双向关联 123456789101112131415public class A&#123; private B b = new B(); public useB()&#123; //使用b做一些事情 &#125;&#125;public class B&#123; private A a = new A(); public void useA()&#123; //使用a做一些事情 &#125;&#125; 另外根据关联的对象的数量又可分为以下几种的关联： 表示方式 说明 1..1 表示一个类的一个对象只与另一个类的一个对象有关联 1..* 表示一个类的一个对象与另一个类的一个或多个对象有关联 0..* 表示一个类的一个对象与另一个类的零个或多个对象有关联 0..1 表示一个类的一个对象与另一个类的零个或一个对象有关联 m..n 表示一个类的一个对象与另一个类的m个到n个对象有关联 两个类之间虽然是存在联系，但是只是在结构上的联系，并没有要求在语义上有联系。两个类在生命周期上是平级关系，其中一个类的消失都不会促使另一个类的消亡，与下面讲述的聚合关系和组合关系有所不同。 3. 聚合关系是一种has-a 的关系，是关联关系的一种特例 表示类A的一个对象拥有另一个类A的实例。 在java中，同样表示为成员变量的形式。但是与普通关联关系有所不同，聚合关系在语义上并不是平级关系，聚合关系的类A 与 类 B 是一种 A has-a B 的关系。而这个b 也可以是多个类共享。 举栗子：电脑与连接在电脑的打印机,电脑拥有一台打印机设备。这台打印机设备属于这台电脑，同时也可以属于其他共享这个打印机的电脑。 4. 组合关系是一种contain-a的关系，也是关联关系的一种特例，区别同样在于语义 表示类A的一个对象包含另一个类B的一个实例对象。 与聚合关系不同在于，聚合关系的a消亡并不会促使b消亡。而组合关系中a的消亡会导致b也跟着消亡，组合关系中a与b也是整体与部分的关系，但部分不能脱离整体而存在。 举个栗子：人和人的头就是组合关系。人一旦死去，头部也会随之消亡。而聚合关系中的例子打印机 可以单独存活于外，电脑死机了，打印机还是连接着其他电脑，但是人的头部恐怕以目前的技术很难接到其他本体吧。 5. 继承关系也称泛化（generalization） 表示一个子类继承了父类。在java中通过关键字extends 实现 这五种类之间的关系的耦合度：继承&gt;组合&gt;聚合&gt;关联&gt;依赖 参考 https://www.jianshu.com/p/ee0c26bcbf3d http://www.cnblogs.com/jiqing9006/p/5915023.html]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
